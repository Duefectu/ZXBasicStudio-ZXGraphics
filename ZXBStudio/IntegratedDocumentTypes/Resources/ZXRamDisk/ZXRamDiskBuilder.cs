using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ZXBasicStudio.BuildSystem;
using ZXBasicStudio.DocumentEditors.ZXRamDisk.Classes;
using ZXBasicStudio.DocumentModel.Classes;
using ZXBasicStudio.DocumentModel.Enums;
using ZXBasicStudio.DocumentModel.Interfaces;
using ZXBasicStudio.Emulator.Classes;
using ZXBasicStudio.IntegratedDocumentTypes.TapeDocuments.ZXTapeBuilder;

namespace ZXBasicStudio.IntegratedDocumentTypes.Resources.ZXRamDisk
{
    public class ZXRamDiskBuilder : IZXDocumentBuilder
    {

        public Guid Id => Guid.Parse("42257fd1-d649-4334-813a-de3b81a54654");

        public Guid[]? DependsOn => null;

        static readonly string mainTemplate = @"''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'INCLUDE THIS FILE AT THE FIRST LINE IN THE MAIN PROGRAM TO  '
'ENSURE THE CODE IS NOT STORED IN THE BANKING AREA           '
'                                                            '
'THIS FILE IS AUTOGENERATED, ANY CHANGE WILL BE LOST ON BUILD'
'                                                            '
'THIS LIBRARY ASSUMES BASE 0 FOR ARRAYS                      '
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

{disk_template}

DIM dummy AS UINTEGER
{indirect_defs_template}{stack_defs_template}
'transfer source bank
DIM rdkTransferBank AS UBYTE = 0
'transfer source address
DIM rdkSrcAddress AS UINTEGER = 0
'transfer destination address
DIM rdkDstAddress AS UINTEGER = 0
'transfer size
DIM rdkSize AS UINTEGER = 0
'used banks
DIM banks({banks_count}) AS UBYTE => {{banks}}

LET dummy = @rdkTransferBank
LET dummy = @rdkSrcAddress
LET dummy = @rdkDstAddress
LET dummy = @rdkSize
LET dummy = @banks

'Assembler code for memory transfers
ASM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Macros                                           ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
{prologue_epilogue_template}

#DEFINE CP16() \
OR A \
SBC HL, DE \
ADD HL, DE

#define BANKM 23388

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Skip assembler code at boot                      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
JP RAMDSK_PROTECTED_END

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Transfer data directly from/to a bank            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RDK_DIRECT_TRANSFER:
PROC

RDK_PROC_PROLOGUE()

LD A, (_rdkTransferBank)
CALL RDK_SWITCH_BANK        ;enable bank

LD DE, (_rdkDstAddress)     ;load transfer parameters
LD HL, (_rdkSrcAddress)
LD BC, (_rdkSize)

LDIR                        ;transfer data

XOR A
CALL RDK_SWITCH_BANK        ;restore bank 0

RDK_PROC_EPILOGUE()

RET                         ;return
ENDP

{indirect_functions_template}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Switch to bank specified in A                    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RDK_SWITCH_BANK:
PROC

LD C, A
LD A, (BANKM)
AND $F8
OR C
LD BC, $7ffd
OUT (C), A
LD (BANKM), A

RET
ENDP

RAMDSK_PROTECTED_END:

END ASM

'Call this function the first in your program in order to
'load the banks data
SUB LoadRamDisk()

    DIM buc AS UBYTE
    
    
    FOR buc = 0 TO {banks_count}

        rdkTransferBank = banks(buc)

        ASM
            LD A, (_rdkTransferBank)    
            RDK_PROC_PROLOGUE()
            CALL RDK_SWITCH_BANK
            EI
        
        END ASM
    
        LOAD """" CODE $C000
    
        ASM
    
            DI
            CALL RDK_SWITCH_BANK
            RDK_PROC_EPILOGUE()
        
        END ASM

    NEXT buc

END SUB

{basic_functions_template}
";

        static readonly string proEpTemplateRelocate = @"#DEFINE RDK_PROC_PROLOGUE() \
DI                          ;disable interrupts \
LD (_rdkOldStack), SP       ;preserve old stack pointer \
LD SP, _rdkTmpStack.__DATA__ + 32    ;place the stack at the temp location

#DEFINE RDK_PROC_EPILOGUE() \
LD SP, (_rdkOldStack)       ;restore stack \
EI                          ;enable interrupts";
        static readonly string proEpTemplateNoRelocate = @"#DEFINE RDK_PROC_PROLOGUE() \
DI                          ;disable interrupts

#DEFINE RDK_PROC_EPILOGUE() \
EI                          ;enable interrupts";

        static readonly string relocateDefsTemplate = @"'stack preservation for ram disk operations
DIM rdkTmpStack(15) AS UINTEGER
DIM rdkOldStack AS UINTEGER = 0
LET dummy = @rdkTmpStack
LET dummy = @rdkOldStack";
        static readonly string indirectDefsTemplate = @"'Indirect buffer size, the bigger the faster the indirect
'copies will work
#DEFINE INDIRECT_BUFFER_SIZE {indirect_size}
'indirect transfer buffer
DIM rdkTransferBuffer(INDIRECT_BUFFER_SIZE - 1) AS UBYTE
LET dummy = @rdkTransferBuffer
";

        static readonly string indirectAsmFuncsTemplate = @";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Transfer data from a bank to bank zero via buffer;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RDK_INDIRECT_READ:
PROC
LOCAL indirect_loop
LOCAL copy_block
LOCAL transfer_finished
LOCAL finalblock

RDK_PROC_PROLOGUE()

LD HL, (_rdkSize)           ;load size to copy, only for first loop

indirect_loop:

LD A, (_rdkTransferBank)    ;change to source bank
CALL RDK_SWITCH_BANK

LD DE, INDIRECT_BUFFER_SIZE

CP16()                      ;compare it with the indirect buffer size

JP Z, finalblock            ;if it's bigger than the buffer restrict the transfer size
JP C, finalblock
LD BC, INDIRECT_BUFFER_SIZE
JP copy_block

finalblock:

LD BC, (_rdkSize)           ;else use it

copy_block:

PUSH BC                     ;preserve transfer size

LD DE, _rdkTransferBuffer.__DATA__     ;copy to temp buffer
LD HL, (_rdkSrcAddress)
LDIR

LD (_rdkSrcAddress), HL     ;preserve next source address

XOR A                       ;change to bank 0
CALL RDK_SWITCH_BANK        

POP BC                      ;restore transfer size
PUSH BC                     ;preserve again

LD DE, (_rdkDstAddress) ;copy from temp buffer
LD HL, _rdkTransferBuffer.__DATA__
LDIR 

LD (_rdkDstAddress), DE     ;preserve next destination address

POP DE                      ;restore the size we have transferred and subtract it from the transfer size
LD HL, (_rdkSize)
OR A
SBC HL, DE

JP Z, transfer_finished     ;if there is no more to copy, end procedure

LD (_rdkSize), HL           ;store size left

JP indirect_loop            ;next loop

transfer_finished:

RDK_PROC_EPILOGUE()

RET
ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Transfer data from bank zero to a bank via buffer;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RDK_INDIRECT_WRITE:
PROC
LOCAL indirect_loop
LOCAL copy_block
LOCAL transfer_finished
LOCAL finalblock

RDK_PROC_PROLOGUE()

LD HL, (_rdkSize)           ;load size to copy, only for first loop

indirect_loop:

LD DE, INDIRECT_BUFFER_SIZE

CP16()                      ;compare it with the indirect buffer size

JP Z, finalblock            ;if it's bigger than the buffer restrict the transfer size
JP C, finalblock
LD BC, INDIRECT_BUFFER_SIZE
JP copy_block

finalblock:

LD BC, (_rdkSize)           ;else use it

copy_block:

PUSH BC                     ;preserve transfer size

LD DE, _rdkTransferBuffer.__DATA__     ;copy to temp buffer
LD HL, (_rdkSrcAddress)
LDIR

LD (_rdkSrcAddress), HL     ;preserve next source address

LD A, (_rdkTransferBank)    ;change to destination bank
CALL RDK_SWITCH_BANK

POP BC                      ;restore transfer size
PUSH BC                     ;preserve again

LD DE, (_rdkDstAddress)     ;copy from temp buffer
LD HL, _rdkTransferBuffer.__DATA__
LDIR 

XOR A                       ;change to bank 0
CALL RDK_SWITCH_BANK        

LD (_rdkDstAddress), DE     ;preserve next destination address

POP DE                      ;restore the size we have transferred and subtract it from the transfer size
LD HL, (_rdkSize)
OR A
SBC HL, DE

JP Z, transfer_finished     ;if there is no more to copy, end procedure

LD (_rdkSize), HL           ;store size left

JP indirect_loop            ;next loop

transfer_finished:

RDK_PROC_EPILOGUE()

RET
ENDP
";

        static readonly string indirectBasicSubsTemplate = @"'Loads data from a RAM disk
SUB LoadRamData(BYVAL DiskNumber AS UBYTE, BYVAL Source as UINTEGER, BYVAL Destination as UINTEGER, BYVAL Length as UINTEGER)

    rdkTransferBank = DiskNumber
    rdkSrcAddress = Source
    rdkDstAddress = Destination
    rdkSize = Length
    
    IF Destination + Length - 1 >= $c000 then
    
        'indirect copy
        ASM
        CALL RDK_INDIRECT_READ
        END ASM
        
    ELSE
    
        'direct copy
        ASM
        CALL RDK_DIRECT_TRANSFER
        END ASM
        
    END IF 

END SUB

'Saves data to a RAM disk
SUB SaveRamData (BYVAL DiskNumber AS UBYTE, BYVAL Source as UINTEGER, BYVAL Destination as UINTEGER, BYVAL Length as UINTEGER)

    rdkTransferBank = DiskNumber
    rdkSrcAddress = Source
    rdkDstAddress = Destination
    rdkSize = Length

    IF Source + Length - 1 >= $c000 then
    
        'indirect copy
        ASM
        CALL RDK_INDIRECT_WRITE
        END ASM
        
    ELSE
    
        'direct copy
        ASM
        CALL RDK_DIRECT_TRANSFER
        END ASM
        
    END IF 

END SUB";
        static readonly string noIndirectBasicSubsTemplate = @"'Loads data from a RAM disk
SUB LoadRamData(BYVAL DiskNumber AS UBYTE, BYVAL Source as UINTEGER, BYVAL Destination as UINTEGER, BYVAL Length as UINTEGER)

    rdkTransferBank = DiskNumber
    rdkSrcAddress = Source
    rdkDstAddress = Destination
    rdkSize = Length

    'indirect copy
    ASM
    CALL RDK_DIRECT_TRANSFER
    END ASM

END SUB

#define SaveRamData (DiskNumber,Source,Destination,Length) LoadRamData(DiskNumber,Source,Destination,Length)";

        public bool Build(string BuildPath, ZXBuildStage Stage, ZXBuildType BuildType, ZXProgram? CompiledProgram, TextWriter OutputLog)
        {
            switch (Stage)
            {
                case ZXBuildStage.PreBuild:

                    return BuildDiskAndCode(BuildPath, BuildType, OutputLog);

                case ZXBuildStage.PostBuild:

                    if (CompiledProgram == null)
                        return false;

                    return InjectDisk(BuildPath, CompiledProgram, OutputLog);
            }

            return false;
        }

        private bool InjectDisk(string buildPath, ZXProgram compiledProgram, TextWriter outputLog)
        {
            string[] diskBuilds = Directory.GetFiles(buildPath, "*" + ZXDocumentProvider.GetDocumentTypeInstance(typeof(ZXRamDiskDocument)).DocumentExtensions[0], SearchOption.AllDirectories);

            if (diskBuilds == null || diskBuilds.Length == 0)
                return true;

            if(diskBuilds.Length > 1) 
            {
                outputLog.WriteLine("Found more than one RAM disk, aborting...");
                return false;
            }

            var diskPath = diskBuilds[0];
            
            string fileName = Path.GetFileName(diskPath);
            outputLog.WriteLine($"Injecting RAM disk {fileName}...");

            try
            {
                ZXRamDiskFile diskFile = JsonConvert.DeserializeObject<ZXRamDiskFile>(File.ReadAllText(diskPath));

                foreach (var bank in diskFile.Banks)
                {

                    if (bank.Files.Count == 0)
                        continue;

                    string bankFile = diskPath.Substring(0, diskPath.Length - 4) + $"_{(int)bank.Bank}.zxrbin";

                    byte[] binFile = File.ReadAllBytes(bankFile);

                    compiledProgram.Banks.Add(new ZXBinaryBank { Identifier = Path.GetFileNameWithoutExtension(bankFile),  Bank = bank.Bank, Data = binFile });

                    if (!diskFile.PreserveBin)
                        File.Delete(bankFile);
                }
            }
            catch (Exception ex)
            {
                outputLog.WriteLine($"Error injecting RAM disk {diskPath}: \r\n" + ex.ToString());
                return false;
            }
            

            return true;
        }

        private bool BuildDiskAndCode(string buildPath, ZXBuildType BuildType, TextWriter outputLog)
        {
            string[] diskBuilds = Directory.GetFiles(buildPath, "*" + ZXDocumentProvider.GetDocumentTypeInstance(typeof(ZXRamDiskDocument)).DocumentExtensions[0], SearchOption.AllDirectories);

            if (diskBuilds == null || diskBuilds.Length == 0)
                return true;

            if (diskBuilds.Length > 1)
            {
                outputLog.WriteLine("Found more than one RAM disk, aborting...");
                return false;
            }

            var diskPath = diskBuilds[0];

            string fileName = Path.GetFileName(diskPath);
            string diskName = Path.GetFileNameWithoutExtension(diskPath);

            outputLog.WriteLine($"Generating RAM disk {fileName}...");

            try
            {
                ZXRamDiskFile diskFile = JsonConvert.DeserializeObject<ZXRamDiskFile>(File.ReadAllText(diskPath));

                if (diskFile == null)
                {
                    outputLog.WriteLine($"Error reading RAM disk {diskPath}, aborted.");
                    return false;
                }

                StringBuilder sb = new StringBuilder();

                sb.Append($"#define Load{diskName}()");

                foreach (var bank in diskFile.Banks)
                {
                    if(bank.Files.Count > 0) 
                        sb.Append($" \\\r\nLoadRamBank({(int)bank.Bank})");
                }

                sb.Append("\r\n");

                List<int> usedBanks = new List<int>();

                foreach (var bank in diskFile.Banks)
                {
                    if (bank.Files.Count == 0)
                        continue;
                        
                    usedBanks.Add((int)bank.Bank);

                    List<byte> data = new List<byte>();

                    foreach (var file in bank.Files)
                    {
                        sb.AppendLine($"#define {file.Name}Address {data.Count + 0xC000}");
                        byte[] fileData = file.Content;

                        data.AddRange(fileData);
                        sb.AppendLine($"#define {file.Name}Size {fileData.Length}");
                        sb.AppendLine($"#define {file.Name}Bank {(int)bank.Bank}");

                        sb.AppendLine($"#define Load{file.Name}From{diskName}(Dest) LoadRamData({file.Name}Bank, {file.Name}Address, Dest, {file.Name}Size)");

                        sb.AppendLine($"#define LoadPartial{file.Name}From{diskName}(Dest, Size) LoadRamData({file.Name}Bank, {file.Name}Address, Dest, Size)");
                    }

                    outputLog.WriteLine($"Writting binary bank {(int)bank.Bank}...");
                    File.WriteAllBytes(diskPath.Substring(0, diskPath.Length - 4) + $"_{(int)bank.Bank}.zxrbin", data.ToArray());
                }

                outputLog.WriteLine("Writting include file...");

                string mainContent = mainTemplate.Replace("{disk_template}", sb.ToString())
                    .Replace("{banks_count}", (usedBanks.Count - 1).ToString())
                    .Replace("{banks}", string.Join(", ", usedBanks.Select(b => b.ToString())));

                if (diskFile.EnableIndirect)
                {
                    mainContent = mainContent.Replace("{indirect_defs_template}", indirectDefsTemplate.Replace("{indirect_size}", diskFile.IndirectBufferSize.ToString()))
                        .Replace("{indirect_functions_template}", indirectAsmFuncsTemplate)
                        .Replace("{basic_functions_template}", indirectBasicSubsTemplate);
                }
                else
                {
                    mainContent = mainContent.Replace("{indirect_defs_template}", "")
                        .Replace("{indirect_functions_template}", "")
                        .Replace("{basic_functions_template}", noIndirectBasicSubsTemplate);
                }

                if (diskFile.RelocateStack)
                {
                    mainContent = mainContent.Replace("{stack_defs_template}", relocateDefsTemplate)
                        .Replace("{prologue_epilogue_template}", proEpTemplateRelocate);
                }
                else
                {
                    mainContent = mainContent.Replace("{stack_defs_template}", "")
                        .Replace("{prologue_epilogue_template}", proEpTemplateNoRelocate);
                }

                File.WriteAllText(diskPath.Substring(0, diskPath.Length - 4) + ".zxbas", mainContent);
                outputLog.WriteLine($"RAM disk {fileName} successfully built.");
            }
            catch (Exception ex)
            {
                outputLog.WriteLine($"Error generating RAM disk {diskPath}: \r\n" + ex.ToString());
                return false;
            }
            

            return true;
        }
    }
}
